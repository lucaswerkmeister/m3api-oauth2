/* eslint camelcase: off */
// OAuth 2.0 POST parameters use underscores

import {
	DEFAULT_OPTIONS,
} from 'm3api/core.js';

/**
 * Request options understood by this package.
 * All other options will be passed through to m3api.
 *
 * @typedef Options
 * @type {Object}
 * @property {OAuthClient} ['m3api-oauth2/client']
 * The OAuth client, encapsulating the credentials.
 * This option must be specified, there is no possible default value.
 * (It’s recommended to set it in the session’s default options.)
 * @property {boolean} ['m3api-oauth2/assert']
 * Whether to set the 'assert' parameter in the session’s defaultParams to 'user'.
 * Defaults to true.
 */

Object.assign( DEFAULT_OPTIONS, {
	'm3api-oauth2/client': { // the default is a fake OAuthClient to throw a more helpful exception
		get clientId() {
			throw new Error( 'The m3api-oauth2/client request option was not specified!' );
		},
	},
	'm3api-oauth2/assert': true,
} );

/** @private */
const clientSecretSymbol = Symbol( 'OAuthClient.clientSecret' );
/** @private */
const accessTokenSymbol = Symbol( 'accessToken' );

/**
 * An OAuth 2.0 client, encapsulating the client ID and client secret.
 * (Both are generated by MediaWiki when the client is created.)
 */
class OAuthClient {

	/**
	 * @param {string} clientId The public client ID,
	 * sometimes known as the consumer token in MediaWiki.
	 * Usually 32 hexadecimal characters.
	 * @param {string} clientSecret The client secret,
	 * sometimes known as the secret token in MediaWiki.
	 * Usually 40 hexadecimal characters.
	 */
	constructor( clientId, clientSecret ) {
		/** @public */
		this.clientId = clientId;
		/** @private */
		Object.defineProperty( this, clientSecretSymbol, { value: clientSecret } );
	}

}

/**
 * Get the URL to authorize a user.
 *
 * You should send the user to this URL,
 * then later call {@link completeOAuthSession} once they’ve been redirected back to you.
 *
 * This function needs to be async for technical reasons,
 * but should resolve basically immediately
 * (no server communication is involved).
 *
 * @param {Session} session The session with which the authorization will be associated.
 * @param {Options} [options] Request options.
 * The 'm3api-oauth2/client' option must be specified
 * either here or in the session’s default options.
 * @return {string}
 */
async function initOAuthSession( session, options = {} ) {
	const { 'm3api-oauth2/client': client } = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};
	const restUrl = session.apiUrl.replace( /api\.php$/, 'rest.php' );
	const clientId = client.clientId;
	return `${restUrl}/oauth2/authorize?response_type=code&client_id=${clientId}`;
}

/**
 * Handle an authorization callback from the user.
 *
 * Call this method when the user returns from the {@link initOAuthSession} result,
 * with the full URL they were redirected to.
 * The session will be set up for authenticated requests.
 *
 * @param {Session} session The session to which the authorization will apply.
 * @param {string} callbackUrl The URL the user was redirected to.
 * @param {Options} [options] Request options.
 * The 'm3api-oauth2/client' option must be specified
 * either here or in the session’s default options.
 */
async function completeOAuthSession( session, callbackUrl, options = {} ) {
	const {
		'm3api-oauth2/client': client,
		// 'm3api-oauth2/assert' handled in deserializeOAuthSession()
	} = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};
	const restUrl = session.apiUrl.replace( /api\.php$/, 'rest.php' );
	const accessTokenUrl = `${restUrl}/oauth2/access_token`;
	const code = new URL( callbackUrl ).searchParams.get( 'code' );
	const { status, body } = await session.internalPost( accessTokenUrl, {}, {
		grant_type: 'authorization_code',
		code,
		client_id: client.clientId,
		client_secret: client[ clientSecretSymbol ],
	}, { 'user-agent': session.getUserAgent( options ) } );

	if ( status !== 200 ) {
		throw new Error( `OAuth request returned non-200 HTTP status code: ${status}` );
	}

	const accessToken = body.access_token;
	deserializeOAuthSession( session, { accessToken }, options );
}

/**
 * Serialize the OAuth components of the given session,
 * so they can be stored in the user session (in some kind of session store).
 *
 * You should NOT let the user directly access the serialization
 * (e.g. by storing it in a cookie) –
 * that would let them impersonate your application
 * by making requests directly that appear to come from your app.
 *
 * The serialization is an opaque value,
 * JSON-serializable but otherwise only suitable
 * for passing it into {@link deserializeOAuthSession}.
 * Don’t do anything else with it.
 *
 * @param {Session} session The session whose OAuth components should be serialized.
 * @param {Options} [options] Included for consistency with the other functions;
 * currently does nothing.
 * @return {Object.<string, string>} A JSON-serializable object
 * with unspecified structure.
 * Passing a copy of this object into {@link deserializeOAuthSession}
 * will make another session equivalent as far as OAuth is concerned.
 */
// eslint-disable-next-line no-unused-vars
function serializeOAuthSession( session, options = {} ) {
	const serialization = {};
	if ( Object.prototype.hasOwnProperty.call( session, accessTokenSymbol ) ) {
		serialization.accessToken = session[ accessTokenSymbol ];
	}
	return serialization;
}

/**
 * Deserialize OAuth components into the given session,
 * making it equivalent to the session the serialization came from
 * (as far as OAuth is concerned).
 *
 * @param {Session} session The session that the serialization should be applied to.
 * @param {Object.<string, string>} serialization A serialization that was
 * returned by {@link serializeOAuthSession} (and possibly JSON-serialized in between).
 * @param {Options} [options] The 'm3api-oauth2/assert' option
 * has the same meaning here as in {@link completeOAuthSession};
 * if you customize the options, it’s recommended to pass the same options to both functions.
 */
function deserializeOAuthSession( session, serialization, options = {} ) {
	const {
		'm3api-oauth2/assert': assert,
	} = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};

	if ( Object.prototype.hasOwnProperty.call( serialization, 'accessToken' ) ) {
		const accessToken = serialization.accessToken;
		Object.defineProperty( session, accessTokenSymbol, { value: accessToken } );
		session.defaultOptions.authorization = `Bearer ${accessToken}`;
		if ( assert ) {
			session.defaultParams.assert = 'user';
		}
	}
}

export {
	OAuthClient,
	initOAuthSession,
	completeOAuthSession,
	serializeOAuthSession,
	deserializeOAuthSession,
};
