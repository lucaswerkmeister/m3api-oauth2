/* eslint camelcase: off */
// OAuth 2.0 POST parameters use underscores

import {
	DEFAULT_OPTIONS,
} from 'm3api/core.js';

/**
 * Get an instance of the Web Crypto API.
 *
 * @private
 * @return {Crypto}
 */
async function webCrypto() {
	if ( typeof crypto !== 'undefined' ) {
		return crypto;
	}

	if ( typeof global === 'object' ) {
		try {
			const nodeCrypto = await import( 'node:crypto' )
				.catch( () => import( 'crypto' ) );
			if ( typeof nodeCrypto.webcrypto !== 'undefined' ) {
				return nodeCrypto.webcrypto;
			}
		} catch ( _ ) {
			// ignore
		}
	}

	throw new Error( 'Web Crypto API is required!' );
}

/**
 * Request options understood by this package.
 * All other options will be passed through to m3api.
 *
 * @typedef Options
 * @type {Object}
 * @property {OAuthClient} ['m3api-oauth2/client']
 * The OAuth client, encapsulating the credentials.
 * This option must be specified, there is no possible default value.
 * (It’s recommended to set it in the session’s default options.)
 * @property {boolean} ['m3api-oauth2/assert']
 * Whether to set the 'assert' parameter in the session’s defaultParams to 'user'.
 * Defaults to true.
 * @property {boolean} ['m3api-oauth2/autoRefresh']
 * Whether to automatically {@link refreshOAuthSession refresh the OAuth session}
 * when the access token expired.
 * Defaults to true.
 * There’s little reason for an end user to set this option to false,
 * but it’s used internally to avoid an infinite refresh loop.
 */

Object.assign( DEFAULT_OPTIONS, {
	'm3api-oauth2/client': { // the default is a fake OAuthClient to throw a more helpful exception
		get clientId() {
			throw new Error( 'The m3api-oauth2/client request option was not specified!' );
		},
	},
	'm3api-oauth2/assert': true,
	'm3api-oauth2/autoRefresh': true,
} );

/**
 * Handle an invalid authorization error (likely due to an expired access token)
 * by refreshing the access token and, if there’s enough time left,
 * retrying the request.
 *
 * @param {Session} session
 * @param {Object} params
 * @param {Options} options
 * @return {Object|null|Promise<Object|null>}
 */
async function handleInvalidAuthorizationError( session, params, options ) {
	const {
		retryUntil,
		'm3api-oauth2/autoRefresh': autoRefresh,
	} = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};
	if ( !autoRefresh ) {
		return null;
	}
	await refreshOAuthSession( session, options );
	if ( typeof performance !== 'object' ) {
		throw new Error( 'performance global is required!' );
	}
	if ( performance.now() <= retryUntil ) {
		return session.request( params, {
			...options,
			'm3api-oauth2/autoRefresh': false,
		} );
	} else {
		return null;
	}
}

DEFAULT_OPTIONS.errorHandlers[ 'mwoauth-invalid-authorization' ] = handleInvalidAuthorizationError;

/** @private */
const clientSecretSymbol = Symbol( 'OAuthClient.clientSecret' );
/** @private */
const codeVerifierSymbol = Symbol( 'codeVerifier' );
/** @private */
const accessTokenSymbol = Symbol( 'accessToken' );
/** @private */
const refreshTokenSymbol = Symbol( 'refreshToken' );

/**
 * An OAuth 2.0 client, encapsulating the client ID and optional client secret.
 * (Both are generated by MediaWiki when the client is created.)
 */
class OAuthClient {

	/**
	 * @param {string} clientId The public client ID,
	 * sometimes known as the consumer token in MediaWiki.
	 * Usually 32 hexadecimal characters.
	 * @param {string|null} [clientSecret] The client secret,
	 * sometimes known as the secret token in MediaWiki.
	 * Usually 40 hexadecimal characters.
	 * Can be omitted or set to null for non-confidential clients;
	 * however, non-confidential clients can also still use a client secret:
	 * see {@link https://phabricator.wikimedia.org/T323867 T323867} for discussion.
	 */
	constructor( clientId, clientSecret = null ) {
		/** @public */
		this.clientId = clientId;
		/** @private */
		Object.defineProperty( this, clientSecretSymbol, { value: clientSecret } );
	}

}

/**
 * Initialize an OAuth session,
 * and generate the URL to authorize a user.
 *
 * You should send the user to this URL,
 * then later call {@link completeOAuthSession} once they’ve been redirected back to you.
 *
 * This function needs to be async for technical reasons,
 * but should resolve basically immediately
 * (no server communication is involved).
 *
 * Calling this function multiple times on the same session
 * (or on a serialized+deserialized copy) returns the same URL.
 * Therefore, it’s recommended to call this function each time you need the URL,
 * rather than storing the URL externally (e.g. in the user session).
 *
 * @param {Session} session The m3api session with which the authorization will be associated.
 * @param {Options} [options] Request options.
 * The 'm3api-oauth2/client' option must be specified
 * either here or in the session’s default options.
 * @return {string}
 */
async function initOAuthSession( session, options = {} ) {
	const {
		'm3api-oauth2/client': client,
	} = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};
	if ( !Object.prototype.hasOwnProperty.call( session, codeVerifierSymbol ) ) {
		const codeVerifier = await newCodeVerifier();
		Object.defineProperty( session, codeVerifierSymbol, {
			value: codeVerifier,
			configurable: true,
		} );
	}
	const restUrl = session.apiUrl.replace( /api\.php$/, 'rest.php' );
	const params = new URLSearchParams( {
		response_type: 'code',
		client_id: client.clientId,
		...await getCodeChallenge( session[ codeVerifierSymbol ] ),
	} );
	return `${ restUrl }/oauth2/authorize?${ params }`;
}

/**
 * Generate a new code verifier,
 * a string using the characters A-Z, a-z, 0-9, or -._~, between 43 and 128 characters long.
 *
 * We use 64 of the 66 possible characters (to simplify the maths),
 * and the minimum length of 43 characters,
 * which should provide 258 bits of entropy – more than enough.
 *
 * @private
 * @return {string}
 */
async function newCodeVerifier() {
	const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_~';

	const crypto = await webCrypto();
	const bytes = new Uint8Array( 43 );
	crypto.getRandomValues( bytes );

	let verifier = '';
	for ( let i = 0; i < 43; i++ ) {
		// eslint-disable-next-line no-bitwise
		verifier += characters[ bytes[ i ] & 63 ];
	}
	return verifier;
}

/**
 * Get the code challenge for the given code verifier.
 *
 * @private
 * @param {string} codeVerifier As generated by {@link newCodeVerifier}.
 * @return {Object} To be mixed into the authorization request parameters.
 */
async function getCodeChallenge( codeVerifier ) {
	const crypto = await webCrypto();
	if ( typeof btoa !== 'function' ) {
		throw new Error( 'btoa() (Base64-encode) is required!' );
	}
	const codeVerifierBytes = new TextEncoder().encode( codeVerifier );
	const hashBytes = await crypto.subtle.digest( 'SHA-256', codeVerifierBytes );
	const hashString = String.fromCharCode.apply( null, new Uint8Array( hashBytes ) );
	const codeChallenge = btoa( hashString )
		.replace( /\+/g, '-' )
		.replace( /\//g, '_' )
		.replace( /=+$/, '' );
	return {
		code_challenge: codeChallenge,
		code_challenge_method: 'S256',
	};
}

/**
 * Handle an authorization callback from the user,
 * and complete an OAuth session.
 *
 * Call this method when the user returns from the {@link initOAuthSession} result,
 * with the URL they were redirected to (including the search / query parameters).
 * The m3api session will be set up for authenticated requests
 * (becoming an OAuth session).
 *
 * @param {Session} session The m3api session to which the authorization will apply.
 * @param {string} callbackUrl The URL the user was redirected to.
 * This may be an absolute or relative URL; only the parameters are important.
 * @param {Options} [options] Request options.
 * The 'm3api-oauth2/client' option must be specified
 * either here or in the session’s default options.
 */
async function completeOAuthSession( session, callbackUrl, options = {} ) {
	const {
		'm3api-oauth2/client': client,
		// 'm3api-oauth2/assert' handled in deserializeOAuthSession()
	} = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};
	const restUrl = session.apiUrl.replace( /api\.php$/, 'rest.php' );
	const accessTokenUrl = `${ restUrl }/oauth2/access_token`;
	const code = new URL( callbackUrl, 'http://ignored.invalid' ).searchParams.get( 'code' );
	const codeVerifier = session[ codeVerifierSymbol ];
	delete session[ codeVerifierSymbol ];
	if ( !code ) {
		throw new Error( `Invalid callback URL (missing ?code= parameter): ${ callbackUrl }` );
	}
	const clientParams = { client_id: client.clientId };
	if ( client[ clientSecretSymbol ] !== null ) {
		clientParams.client_secret = client[ clientSecretSymbol ];
	}
	const { status, body } = await session.internalPost( accessTokenUrl, {}, {
		grant_type: 'authorization_code',
		code,
		...clientParams,
		code_verifier: codeVerifier,
	}, { 'user-agent': session.getUserAgent( options ) } );

	if ( status !== 200 ) {
		throw new Error( `OAuth request returned non-200 HTTP status code: ${ status }` );
	}

	const {
		access_token: accessToken,
		refresh_token: refreshToken,
	} = body;
	deserializeOAuthSession(
		session,
		{ accessToken, refreshToken },
		options,
	);
}

/**
 * Determine whether the session is complete.
 *
 * If this function returns true,
 * then the session was successfully {@link completeOAuthSession completed}
 * and can be used to make authenticated requests.
 * (This doesn’t guarantee that the requests will succeed,
 * as the user may have revoked the permission in the meantime.)
 * If the function returns false, then the session has not been completed yet,
 * and you should call {@link initOAuthSession} and send the user to the returned authorization URL.
 *
 * @param {Session} session
 * @return {boolean}
 */
function isCompleteOAuthSession( session ) {
	return Object.prototype.hasOwnProperty.call( session, accessTokenSymbol );
}

/**
 * Refresh the OAuth session, getting a new access token.
 *
 * Access tokens generated by MediaWiki are short-lived (4 hours),
 * so they need to be refreshed periodically.
 * m3api-oauth2 arranges for this to happen automatically,
 * so there is generally no need to call this function manually.
 *
 * Note that refreshing the access token currently requires the client secret,
 * see {@link https://phabricator.wikimedia.org/T323855 T323855}.
 * (That is, non-confidential clients *can* use this function,
 * but only if they use their client secret.)
 *
 * @param {Session} session The OAuth session whose access token should be refreshed.
 * @param {Options} [options] Request options.
 * The 'm3api-oauth2/client' option must be specified
 * either here or in the session’s default options.
 */
async function refreshOAuthSession( session, options = {} ) {
	const {
		'm3api-oauth2/client': client,
		// 'm3api-oauth2/assert' handled in deserializeOAuthSession()
	} = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};
	const restUrl = session.apiUrl.replace( /api\.php$/, 'rest.php' );
	const accessTokenUrl = `${ restUrl }/oauth2/access_token`;
	const clientParams = { client_id: client.clientId };
	if ( client[ clientSecretSymbol ] !== null ) {
		clientParams.client_secret = client[ clientSecretSymbol ];
	}
	const { status, body } = await session.internalPost( accessTokenUrl, {}, {
		grant_type: 'refresh_token',
		refresh_token: session[ refreshTokenSymbol ],
		...clientParams,
	}, { 'user-agent': session.getUserAgent( options ) } );

	if ( status !== 200 ) {
		throw new Error( `OAuth request returned non-200 HTTP status code: ${ status }` );
	}

	const {
		access_token: accessToken,
		refresh_token: refreshToken = session[ refreshTokenSymbol ],
	} = body;
	deserializeOAuthSession(
		session,
		{ accessToken, refreshToken },
		options,
	);
}

/**
 * Serialize the OAuth components of the given OAuth session,
 * so they can be stored in the user session (in some kind of session store).
 *
 * You should NOT let the user directly access the serialization
 * (e.g. by storing it in a cookie) –
 * that would let them impersonate your application
 * by making requests directly that appear to come from your app.
 *
 * The serialization is an opaque value,
 * JSON-serializable but otherwise only suitable
 * for passing it into {@link deserializeOAuthSession}.
 * Don’t do anything else with it.
 *
 * @param {Session} session The OAuth session whose OAuth components should be serialized.
 * @param {Options} [options] Included for consistency with the other functions;
 * currently does nothing.
 * @return {Object.<string, string>} A JSON-serializable object
 * with unspecified structure.
 * Passing a copy of this object into {@link deserializeOAuthSession}
 * will turn another m3api session into an OAuth session equivalent to this one.
 */
// eslint-disable-next-line no-unused-vars
function serializeOAuthSession( session, options = {} ) {
	const serialization = {};
	if ( Object.prototype.hasOwnProperty.call( session, codeVerifierSymbol ) ) {
		serialization.codeVerifier = session[ codeVerifierSymbol ];
	}
	if ( Object.prototype.hasOwnProperty.call( session, accessTokenSymbol ) ) {
		serialization.accessToken = session[ accessTokenSymbol ];
	}
	if ( Object.prototype.hasOwnProperty.call( session, refreshTokenSymbol ) ) {
		serialization.refreshToken = session[ refreshTokenSymbol ];
	}
	return serialization;
}

/**
 * Deserialize OAuth components into the given m3api session,
 * turning it into an OAuth session equivalent to the one the serialization came from.
 *
 * @param {Session} session The m3api session that the serialization should be applied to.
 * @param {Object.<string, string>} serialization A serialization that was
 * returned by {@link serializeOAuthSession} (and possibly JSON-serialized in between).
 * @param {Options} [options] The 'm3api-oauth2/assert' option
 * has the same meaning here as in {@link completeOAuthSession};
 * if you customize the options, it’s recommended to pass the same options to both functions.
 */
function deserializeOAuthSession( session, serialization, options = {} ) {
	const {
		'm3api-oauth2/assert': assert,
	} = {
		...DEFAULT_OPTIONS,
		...session.defaultOptions,
		...options,
	};

	if ( Object.prototype.hasOwnProperty.call( serialization, 'codeVerifier' ) ) {
		const codeVerifier = serialization.codeVerifier;
		Object.defineProperty( session, codeVerifierSymbol, {
			value: codeVerifier,
			configurable: true,
		} );
	}

	if ( Object.prototype.hasOwnProperty.call( serialization, 'accessToken' ) ) {
		const accessToken = serialization.accessToken;
		Object.defineProperty( session, accessTokenSymbol, {
			value: accessToken,
			writable: true,
		} );
		session.defaultOptions.accessToken = accessToken;
		if ( assert ) {
			session.defaultParams.assert = 'user';
		}
	}

	if ( Object.prototype.hasOwnProperty.call( serialization, 'refreshToken' ) ) {
		const refreshToken = serialization.refreshToken;
		Object.defineProperty( session, refreshTokenSymbol, {
			value: refreshToken,
			writable: true,
		} );
	}
}

export {
	OAuthClient,
	initOAuthSession,
	completeOAuthSession,
	isCompleteOAuthSession,
	refreshOAuthSession,
	serializeOAuthSession,
	deserializeOAuthSession,
};
